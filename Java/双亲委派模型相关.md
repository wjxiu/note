## 是什么

当类加载器接收到加载请求的时候，不直接加载，而是交给父类加载，这样所有的请求都会来到appclassloader。如果父类不能加载，会返回给子类加载。

## 好处

保证Java核心类库不受用户自定义类的影响。

保证类不会重复加载

## 如何打破双亲委派模型

只要不交给父类加载器，就是打破了这个模型。所以可以自定义一个类加载器继承classloader，重写loadclass方法。

## 哪些场景破坏了双亲委派模型

TomCat。tomcat允许多个应用运行。如果有两个相同的全类名的类，但是分别属于不同的项目，tomcat可以正常加载这两个类。TomCat就通过破坏双亲委派模型实现。

tomcat给每个应用创建一个类加载器，这个类加载器重写了loadclass方法，优先加载当前应用的类。

## jdbc破坏了~，你是怎么理解的

这个见仁见智，jdbc使用的时候，`DriverManager.getConnection()`返回Connection的实现类，这个实现类是由厂商来实现的。但是Connection接口是存放在rt.jar包下的，是用bootstrap加载器加载，但是jvm规定当A类依赖B类的时候，B类需要用A类的加载器加载，所以实现类是需要bootstrap加载器加载，但是这是不可能的，所以厂商的解决方案就是，在DriverManager初始化的时候，得到「线程上下文加载器」，通过线程上下文加载器加载，但是这个上下文~也是appclassloader。所以有些人认为破坏了，因为应该使用bootstrap加载，但是不是。有人认为没有，因为还是使用了appclassloader。

> 但是jvm规定当A类依赖B类的时候，B类需要用A类的加载器加载(这个我不太懂)