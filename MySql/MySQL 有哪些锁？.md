## MySQL 有哪些锁？

### 全局锁

- 只能读取，其他操作会被阻塞
- 作用：用于备份表数据
- 开启命令：flush tables with read lock
- 关闭命令：unlock tables
- 代替品：使用mvcc机制读取数据

### 表级锁

#### 表锁

```sql
//表级别的共享锁，也就是读锁；当前线程只能读，写报错，其他线程写阻塞,可读
lock tables t_student read;

//表级别的独占锁，也就是写锁；其他线程读写会被阻塞，当前线程读写不影响
lock tables t_stuent write;
释放所有表锁，或者等到session退出
unlock tables
```

#### 元数据锁（MDL）;

 - 防止curd期间防止改变表结构，不需要显式加上mdl锁
 - curd期间加mdl读锁，改变表期间加mdl写锁,mdl读写锁都是互斥的

##### mdl锁什么时候释放

是在事务提交之后才释放，在长事务的情况下可能会阻塞请求。

线程a开启长事务，读取数据此时已经加了mdl读锁，如果线程b修改数据，需要获取mdl写锁，但是mdl读写锁是互斥的，所以获取不到，后面的线程需要读取修改数据都会被阻塞，因为申请mdl锁的操作会形成队列，mdl写锁的优先级高于mdl读锁。为了能安全对表结构变更，变更之前需要查看是否有长事务，等到事务结束之后或者kill掉事务在变更表结构。

#### 意向锁

为了快速判断表是否有加锁，会在表上设置一个意向锁，获取表独占锁之前会获得表的独占意向锁，获得表共享锁之前会获得表的共享意向锁。

意向锁之间是不会竞争的，意向锁和行锁也没有竞争，意向锁会和表锁竞争

#### AUTO-INC 锁

使用到主键自增的时候就会用到auto-inc锁，auto-inc锁不用等到事务结束之后才能释放，而是执行完insert命令之后再释放。

如果一个事务在持有auto-inc锁的时候，别的事务想要获取auto-inc锁就会被阻塞住，也就获取不到主键的值，保证了被AUTO_INCREMENT修饰的字段是连续自增。但是auot-inc锁在执行完insert语句才释放，影响性能，也没有必要，所以版本5.1之后就引入了一个轻量锁，旧的是执行完insert语句才解锁，新的会在获取到自增值后解锁。

##### innodb_autoinc_lock_mode

通过设置innodb_autonic_lock_mode的值控制使用auto-inc锁还是轻量锁。

0：使用auto-inc锁

1：普通插入使用轻量锁，批量插入使用auto-inc锁

2：使用轻量锁

### 行级锁

普通select 锁不会加锁，增删改会加排他锁。但是

`select ... lock in share mode;` 加共享行锁（s）

`select ... for update ` 加独占行锁(x)

这两个语句都是在事务中才能生效。

>  如果不在事务中，执行到上面的语句其一会自动开启事务，查询到结果后自动结束事务。
>
> 如果增删改有多行记录，需要获取到所有行的排他锁才能进行操作，否则阻塞。

只有共享和共享之间是兼容的，剩下的涉及到独占锁的都是不兼容的。

s和x锁都是在事务结束之后才释放的。

行级锁有三类

- record lock,锁住某一行
- gap lock,锁住范围内的行，但是不包括本身
- next-key lock,前面的结合，既锁住当前，也锁一定范围的



#### record lock

只锁住当前行。

在增删改的时候默认加上x型record lock,。

当事务结束之后，record lock也释放了。

普通select 锁不会加锁，增删改会加排他锁。但是

`select ... lock in share mode;` 加共享行锁（s）

`select ... for update ` 加独占行锁(x)

这两个语句都是在事务中才能生效。

>  如果不在事务中，执行到上面的语句其一会自动开启事务，查询到结果后自动结束设置。
>
> 如果增删改有多行记录，需要获取到所有行的排他锁才能进行操作，否则阻塞。

只有共享和共享之间是兼容的，剩下的涉及到独占锁的都是不兼容的。

s和x锁都是在事务结束之后才释放的。

#### Gap Lock

又叫间隙锁，只存在可重复读隔离等级，目的是防止幻读发生。

gap lock虽然有 s,x，但是二者是兼容的。

如果gap lock在事务中获取，那么会持续到事务结束，别的线程无论是否有事务都不能对gap  lock的范围的数据进行增删改



#### Next-Key Lock

record lock+Gap Lock，锁定一个范围，并且锁定记录本身。

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

如果两个事务之间的next key lock有重叠并且 重叠部分是x型锁，会阻塞后一个事务的运行。

#### 插入意向锁

当事务再插入数据时，需要判断是否有其他事务的间隙锁，有的话会阻塞，并且生成一个插入意向锁，表明有事务想要插入新纪录，但是处于等待状态。插入意向锁不是意向锁，而是一种特殊的间隙锁，属于行级别锁。插入意向锁之间不互斥，插入意向锁和排他锁互斥

