# 可重复读解决了幻读问题了吗

## 结论

**没有。但是解决了大部分的。**

推荐记住第一种情况


## 情况一 两次快照读

默认都开启事务。假设表有a，b字段,有99行数据。

| 事务A | 事务B |
| ------------------ | ----- |
| 1 快照读 a>90; |  |
|                    | 2 插入行a=100;并提交 |
| 3 更新a=100的行 |       |
| 4 快照读 a>90; 发现可以读取到a=100的行 | |

### 原因

第一次读取没有加锁，只生成了mvcc

更新a=100，更新成功，因为没有加锁，并且事务B已经提交了。事务B没有提交的话，更新会阻塞

第二次读取可以读取到a=100,因为第三步修改了a=100,最新行的trx_id保存着事务A的id。

### 解决方案

避免更新查询不到的数据

-----

## 情况二 快照读+当前读

默认都开启事务。假设表有a，b字段,有99行数据。

注意：如果是没有加条件，这个情况不会成立

| 事务A                                  | 事务B                |
| -------------------------------------- | -------------------- |
| 1 快照读 a>90;                         |                      |
|                                        | 2 插入行a=100;并提交 |
| 3 当前读 a>90; 发现可以读取到a=100的行 |                      |

### 原因

当前读没有使用mvcc机制，当前读会对最新的数据读取并且加锁

### 解决方案

在开始事务后尽快执行当前读，或者都是用同一种读取方式。查询都用快照读或都用当前读
